\chapter{The Soul of the Machine (Languages)}

Bahasa pemrograman bukanlah sekadar alat untuk memberi perintah kepada mesin. Bahasa pemrograman adalah \textbf{Alat Berpikir}.
Bahasa yang Anda gunakan membentuk cara Anda memandang masalah.
Jika Anda hanya tahu Python, semua masalah terlihat seperti skrip yang bisa diselesaikan dengan \textit{library} impor.
Jika Anda hanya tahu C++, semua masalah terlihat seperti manajemen memori yang harus dioptimalkan.
Jika Anda hanya tahu Haskell, semua masalah terlihat seperti transformasi fungsi murni tanpa efek samping.

Sebagai Artisan, kita harus poliglot. Bukan untuk pamer, tapi untuk memiliki \textbf{Perspektif Multi-Dimensi}.
Kita memilih bahasa berdasarkan \textbf{Karakteristik Jiwa}-nya, bukan berdasarkan popularitasnya di survei Stack Overflow tahunan.

\section{Spektrum Kontrol: Memori dan Mesin}

Keputusan paling fundamental dalam memilih bahasa adalah: \textbf{Siapa yang mengelola memori?}

\subsection{Manual Memory Management (C, C++, Rust)}
Di sini, Anda adalah Tuhan. Anda yang mengalokasikan memori (\texttt{malloc}), dan Anda yang harus membebaskannya (\texttt{free}).
\textbf{Kelebihan:} Kontrol absolut. Nol \textit{overhead}. Prediktabilitas waktu eksekusi yang sempurna (tidak ada \textit{Garbage Collection pauses}).
\textbf{Kekurangan:} Bahaya. \textit{Memory leaks}, \textit{buffer overflows}, dan \textit{use-after-free} adalah monster yang selalu mengintai.
\textbf{Kapan Memilihnya:} Saat Anda membangun:
\begin{enumerate}
    \item \textit{Game Engine} (setiap milidetik berharga).
    \item \textit{Operating System} atau \textit{Database Kernel}.
    \item \textit{High-Frequency Trading System}.
    \item \textit{Embedded Systems} dengan RAM sangat terbatas.
\end{enumerate}

\subsection{Garbage Collection (Java, Go, Python, JS)}
Di sini, Anda menyewa pembantu rumah tangga bernama \textit{Garbage Collector} (GC). Anda membuang sampah sembarangan (membuat objek lalu melupakannya), dan GC akan datang membersihkannya nanti.
\textbf{Kelebihan:} Produktivitas. Anda fokus pada logika bisnis, bukan alokasi memori. Keamanan memori terjamin (hampir tidak mungkin korupsi memori manual).
\textbf{Kekurangan:} Ketidakpastian. GC bisa berjalan kapan saja, menghentikan program Anda selama beberapa milidetik (atau detik!). Penggunaan RAM biasanya 2x-3x lebih boros daripada manajemen manual.
\textbf{Kapan Memilihnya:} Untuk 95\% aplikasi bisnis. Web server, API, skrip otomasi, aplikasi GUI.

\section{Spektrum Kebenaran: Tipe Data}

Keputusan kedua: \textbf{Kapan kesalahan ditemukan?}

\subsection{Static Typing (Java, C++, Rust, Go, TypeScript)}
Tipe data diperiksa saat kompilasi (\textit{Compile Time}).
\textbf{Filosofi:} "Jika kodenya bisa dikompilasi, kemungkinan besar ia benar."
Compiler adalah pasangan pemrograman Anda yang sangat cerewet tapi sangat teliti. Ia menolak kode Anda jika Anda mencoba menjumlahkan Angka dengan String.
\textbf{Kapan Memilihnya:}
\begin{enumerate}
    \item Tim besar (>5 orang). Tipe data berfungsi sebagai dokumentasi yang tidak bisa bohong.
    \item Proyek jangka panjang (>6 bulan). Refactoring kode statis jauh lebih aman karena compiler akan memberi tahu semua bagian yang rusak akibat perubahan Anda.
    \item Sistem kritis (Keuangan, Kesehatan). Kesalahan tipe (\textit{Runtime Error}) tidak bisa ditoleransi.
\end{enumerate}

\subsection{Dynamic Typing (Python, JavaScript, Ruby, PHP)}
Tipe data diperiksa saat program berjalan (\textit{Runtime}).
\textbf{Filosofi:} "Biarkan saya menulis secepat pikiran saya. Kita urus salahnya nanti."
Anda bisa membuat variabel \texttt{x = 1}, lalu di baris berikutnya \texttt{x = "satu"}. Fleksibel, tapi berbahaya.
\textbf{Kapan Memilihnya:}
\begin{enumerate}
    \item Prototyping cepat (\textit{Hackathons}, MVP).
    \item Skrip sekali pakai (\textit{One-off scripts}).
    \item Proyek kecil atau solo developer yang disiplin.
    \item Domain yang sangat dinamis (seperti AI/ML di mana struktur data sering berubah).
\end{enumerate}

\section{Empat Kuda di Kandang Artisan 2026}

Di tahun 2026, seorang Artisan yang lengkap biasanya memiliki penguasaan mendalam pada setidaknya empat bahasa arketipe ini:

\subsection{1. The Systems Master: Rust}
Rust adalah \textbf{C++ yang aman}. Ia memberikan kontrol memori manual tanpa rasa takut akan \textit{segfault}.
Sistem kepemilikan (\textit{Ownership System}) Rust memaksa Anda mengikuti aturan memori ketat saat kompilasi.
Ini sulit dipelajari (\textit{steep learning curve}), tapi hasilnya adalah perangkat lunak yang sangat kuat, sangat cepat, dan sangat aman.
\textbf{Gunakan untuk:} Membangun infrastruktur inti, CLI tools berkinerja tinggi, komponen WebAssembly, dan bagian dari sistem yang tidak boleh gagal.

\subsection{2. The Cloud Native: Go (Golang)}
Go adalah \textbf{C untuk abad ke-21}. Ia membosankan (dalam arti baik). Sederhana, minimalis, dan brutal.
Go tidak punya fitur-fitur mewah seperti \textit{Generics} yang rumit (awalnya) atau \textit{Exceptions}.
Tapi Go punya \textbf{Goroutines}. Konkurensi adalah warga negara kelas satu. Anda bisa menjalankan jutaan proses ringan dengan mudah.
\textbf{Gunakan untuk:} Microservices, Network Programming, gRPC servers, dan alat-alat DevOps (Docker dan K8s ditulis dengan Go). Jika Anda butuh server yang bisa menangani 10.000 request per detik dengan kode yang mudah dibaca tim baru, pilih Go.

\subsection{3. The Glue Code: Python}
Python adalah bahasa kedua terbaik untuk segala hal.
Ia bukan yang tercepat (sangat lambat, faktanya). Ia bukan yang paling aman (dinamis).
Tapi ia memiliki ekosistem \textbf{Library} terbesar di dunia.
Data Science? Pandas. AI? PyTorch. Web? Django. Scripting? Boto3.
Python adalah "Lem Super" (\textit{Super Glue}) yang menghubungkan komponen-komponen sistem yang berbeda.
\textbf{Gunakan untuk:} AI/ML, Data Analysis, Scripting, Prototyping, dan Backend yang tidak mempedulikan latensi mikrotik.

\subsection{4. The Universal Interface: TypeScript}
JavaScript adalah bahasa assembly dari Web. Tapi JavaScript itu kacau.
TypeScript adalah \textbf{JavaScript yang beradab}.
Sistem tipe strukturalnya sangat canggih dan fleksibel. Ia memungkinkan kita membangun aplikasi frontend skala raksasa (React/Next.js) tanpa kehilangan kewarasan.
Dengan munculnya runtime seperti \textbf{Bun} atau \textbf{Deno}, TypeScript kini juga sangat layak untuk backend.
\textbf{Gunakan untuk:} Apa pun yang berjalan di browser, aplikasi mobile (React Native), dan serverless functions yang berfokus pada I/O.

\section{The Unspoken Rule: Ergonomi vs. Performansi}

Banyak insinyur terjebak obsesi prematsur terhadap performansi. "Kita pakai Rust saja biar cepat!"
Artisan tahu aturan emas: \textbf{Waktu Pengembang lebih mahal daripada Waktu CPU.}
Kecuali Anda Google atau Facebook, biaya server Anda mungkin hanya \$500/bulan, sementara gaji pengembang Anda \$5.000/bulan.
Menghemat 10ms waktu respon server dengan menghabiskan 3 bulan waktu pengembangan (karena bahasa yang sulit) adalah ekonomi yang buruk.

Pilihlah bahasa yang:
1.  Membuat Anda produktif (Ergonomi tinggi).
2.  Cukup cepat untuk kebutuhan saat ini.
3.  Memiliki ekosistem yang sehat.

Abaikan \textit{benchmark} sintetis di internet. "Hello World" di Rust memang 100x lebih cepat daripada di Python. Tapi aplikasi nyata dengan koneksi database dan jaringan? Bedanya mungkin hanya 2x-3x. Sering kali, itu tidak signifikan dibandingkan kecepatan fitur yang bisa Anda rilis ke pengguna.

\section{Kesimpulan: Poliglot yang Pragmatis}

Jangan menjadi fanatik bahasa. Jangan mendefinisikan identitas Anda sebagai "Java Developer" atau "Rustacean".
Jadilah "Problem Solver".
Bahasa adalah panah di tabung Anda. Kadang Anda butuh panah api (Python), kadang panah penembus baja (Rust), kadang panah sinyal (JavaScript).
Artisan yang hebat tahu kapan harus mengambil panah yang mana, dan tidak ragu untuk belajar menggunakan busur baru jika medan perang berubah.
